/*
 * Copyright (c) 2019 Andreas FÃ¤rber
 *
 * SPDX-License-Identifier: GPL-2.0-or-later WITH openvpn-openssl-exception
 */

#include <assert.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <openssl/aes.h>
#include <openssl/sha.h>

#include "meson.h"

/*
 * COMPARE_MODE: Define this and change values below to match files
 * generated by aml_encrypt_gxl.
 */
#undef COMPARE_MODE

#ifndef COMPARE_MODE
/*
 * REPRODUCIBLE_OUTPUT: For the benefit of generating reproducible packages,
 * deviate from aml_encrypt_gxl in not using random / time-based values.
 */
#define REPRODUCIBLE_OUTPUT
#endif

static int boot_enc(const char *input, const char *output)
{
	int i;
	FILE *fin, *fout;
	long file_size;
	uint8_t *src_buf, *buf;
	bool is_bl31 = false;
	time_t t;
	struct tm *tm;
	AES_KEY aes_key;
	SHA256_CTX sha256_ctx;
	uint8_t sha256_digest[SHA256_DIGEST_LENGTH], iv[16];
	struct AmlogicCryptoHeader hdr = {
		.sig = AMLOGIC_C_SIGNATURE,
		.block_size = 0x200,
		.encrypted = 0x10001,
		.cipher = "AES-CBC",
		._unknown3 = 0x02000000,
		.sig2 = AMLOGIC_C_SIGNATURE,
	};

	assert(sizeof(hdr) == 0x100);

	fin = fopen(input, "rb");
	if (fin == NULL) {
		perror(input);
		return 1;
	}

	fseek(fin, 0, SEEK_END);
	file_size = ftell(fin);
	fseek(fin, 0, SEEK_SET);

	hdr.data_offset = hdr.block_size;
	hdr.payload_size = ROUND_UP(file_size, hdr.block_size);

	src_buf = malloc(hdr.block_size);
	if (src_buf == NULL)
		return 1;

	memset(src_buf, 0, hdr.block_size);
	fread(src_buf, 1, hdr.block_size, fin);

	if (*(uint32_t*)src_buf == 0x12348765) {
		is_bl31 = true;
	}

	if (is_bl31)
		hdr.payload_size -= hdr.block_size;
	hdr.encrypted_size = hdr.payload_size;
	hdr.first_offset = hdr.payload_size;

	buf = malloc(hdr.data_offset + hdr.payload_size);
	if (buf == NULL) {
		perror("malloc");
		return 1;
	}

	memset(buf, 0, hdr.data_offset + hdr.payload_size);

	if (is_bl31) {
		memcpy(buf + 0x100, src_buf, 0x100);
		memset(src_buf, 0, hdr.block_size);
		fread(src_buf, 1, hdr.block_size, fin);
	}

#ifdef COMPARE_MODE
	tm = malloc(sizeof(*tm));
	if (tm == NULL)
		return 1;
	tm->tm_year = 2019 - 1900;
	tm->tm_mon = 6 - 1;
	tm->tm_mday = 30;
	if (is_bl31) {
	tm->tm_hour = 18;
	tm->tm_min = 33;
	tm->tm_sec = 21;
	} else {
	tm->tm_hour = 2;
	tm->tm_min = 52;
	tm->tm_sec = 16;
	}
#else
	t = time(NULL);
	tm = localtime(&t);
#endif
	strftime(hdr.date, sizeof(hdr.date), "%Y/%m/%d %H:%M:%S", tm);

#ifdef COMPARE_MODE
	if (is_bl31) {
	memcpy(hdr.key, (uint8_t[]){ 0x3e, 0xf9, 0x5c, 0xd7, 0x84, 0x4f, 0xa1, 0xee, 0xb1, 0x6e, 0x66, 0x4d, 0x87, 0xa2, 0x9f, 0x01,
                                     0xfb, 0xc4, 0x83, 0x83, 0x75, 0x86, 0x0e, 0xa9, 0x84, 0x30, 0x6d, 0x7d, 0xf0, 0xe1, 0x5b, 0x2f }, 32);
	memcpy(hdr.iv, (uint8_t[]){ 0xdb, 0xb8, 0x06, 0x5f, 0x07, 0xa8, 0x4e, 0xb8, 0x16, 0xb4, 0x06, 0x9d, 0x56, 0xa5, 0x9e, 0x51 }, 16);
	} else {
	memcpy(hdr.key, (uint8_t[]){ 0x42, 0x16, 0xfc, 0x04, 0x07, 0x8d, 0x65, 0x2e, 0xfd, 0xce, 0xc9, 0xfd, 0x0a, 0x02, 0x45, 0x83,
                                     0x21, 0xba, 0xf2, 0xf1, 0x0f, 0xf3, 0xdf, 0x2c, 0x94, 0x66, 0x30, 0xab, 0x15, 0xfe, 0x86, 0x57 }, 32);
	memcpy(hdr.iv, (uint8_t[]){ 0x14, 0x82, 0x5b, 0x1b, 0x10, 0xc1, 0x49, 0x0d, 0x8f, 0x13, 0x0a, 0x99, 0x15, 0x50, 0x1d, 0x37 }, 16);
	}
#else
	for (i = 0; i < sizeof(hdr.key); i++) {
		hdr.key[i] = rand();
	}
	for (i = 0; i < sizeof(hdr.iv); i++) {
		hdr.iv[i] = rand();
	}
#endif

	fout = fopen(output, "wb");
	if (fout == NULL) {
		perror(output);
		return 1;
	}

	SHA256_Init(&sha256_ctx);
	AES_set_encrypt_key(hdr.key, sizeof(hdr.key) * 8, &aes_key);
	memcpy(iv, hdr.iv, 16);

	AES_cbc_encrypt(src_buf, buf + hdr.first_offset, hdr.block_size, &aes_key, iv, AES_ENCRYPT);
	SHA256_Update(&sha256_ctx, buf + hdr.first_offset, hdr.block_size);

	for (i = 1; i < hdr.payload_size / hdr.block_size; i++) {
		memset(src_buf, 0, hdr.block_size);
		fread(src_buf, 1, hdr.block_size, fin);
		AES_cbc_encrypt(src_buf, buf + hdr.data_offset + (i - 1) * hdr.block_size, hdr.block_size, &aes_key, iv, AES_ENCRYPT);
		SHA256_Update(&sha256_ctx, buf + hdr.data_offset + (i - 1) * hdr.block_size, hdr.block_size);
	}

	memset(sha256_digest, 0, sizeof(sha256_digest));
	SHA256_Final(sha256_digest, &sha256_ctx);
	memcpy(hdr.digest, sha256_digest, sizeof(sha256_digest));

	memcpy(buf, &hdr, sizeof(hdr));

	fwrite(buf, 1, hdr.data_offset + hdr.payload_size, fout);

	fclose(fout);
	fclose(fin);

	return 0;
}

int main(int argc, char **argv)
{
	if (argc < 3) {
		fprintf(stderr, "Usage: %s input output\n", argv[0]);
		return 1;
	}

	return boot_enc(argv[1], argv[2]);
}
